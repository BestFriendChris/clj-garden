test migrations by redoing local db to cljurl_dev, cljurl_test, cljurl_prod
presentable views
presenable error messages
logging in general
  - sql
  - framework: params, routing, timing.
  - exceptions
  - (def *logger* (clj-logger/to-path "log/development.log"))
  - all clojure prns

flash for new url as driver for session store

logging: development
  - see sql queries and their times
    (dedicated, optional sql logging)
  - see how actions are routed
    (test outside of request/response cycle)
  - see response time breakdowns
    (dedicated, optional request timing and profiling middleware)
  
logging: testing
  - probably not useful

logging: production
  - see sql queries and their times
    (buffered flat file dedicated to query times and queries)
    (postgres features)
  - see what requests are leading to 404s
    (dedicated file for 404 request info)
  - grep for long actions, common acitons
    ()
  - see exceptions
    (perhaps good for logging here)
  
perhaps select-with-logging, modify-with-logging

{:type :sql, :time 0.0023 "SELECT * FROM posts WHERE post_at > 12.23.2008"}
{:type :req, :uri "/"}
[req] 
[res]

check crunchbase and feather for init/config requirnements


levels of modularity:
  
  framework level hard coded
    (ns framework.config)
    (def +foo+ :some-unchanging-value)
    only 1 value every possible accross vms and apps
  
  app level hard coded
    (ns app.config)
    (def +foo+ :some-unchanging-value)
    only 1 value for any app within a vm, possible to have app1 and app2 in vm
  
  framework level global
    (swap! framework.config/+foo+ #(identity :some-changeable-value))
    @framework.config/+foo+
    only 1 value accross vms and apps at any 1 time,
    possible to have app(config-a) app(config-b) at different times in same vm
  
  app level global
    (swap! app.config/+foo+ #(identity :some-changeable-value))
    @app.config/+foo+
    only 1 value accross vms for each app at any 1 time,
    possible to have app1(config-a) app1(config-b) at different times in same vm
    also to have app1 and app2 at same or different times in same vm
  
  closures and parameters
    (defn build-app [all-configs]
      (let [controllers (controllers/make (some-subset-of all-configs))]
        (spawn-app controllers)))
    arbitrary number and configuration of apps within vm at arbitrary times,
    but then have to thread paramaters all the way through
    note that thread-local binding of vars is close to the semantics that we
      want, but doesn't quite work with threaded web-apps
    perhaps binding-config macro around app level global situation
    note that only the env needs to be e.g. an atom, everything else is
    an fn of env
    routing is a bit troublesome, v.a.v. the app-root param, could perhaps be
      fixed by seperating somewhat the root from params part
  
  
